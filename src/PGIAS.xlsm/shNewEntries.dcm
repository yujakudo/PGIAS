VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "shNewEntries"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True

'   クリアボタン
Private Sub btnClear_Click()
    Call ClearNewEntries
End Sub

'   作成ボタン
Private Sub btnMakeTables_Click()
    Call makeNewEntries
End Sub

'   期待個体テーブルの作成
Public Sub makeNewEntries()
    Dim sh As Variant
    Dim idx As Integer
    Dim title As String
    Dim isPredict As Boolean
    
    Call doMacro(msgstr(msgMakingSheet, name))
    For idx = 1 To ListObjects.count
        title = ListObjects(idx).HeaderRowRange.cells(1, 1).Offset(-1, 0).Text
        isPredict = (InStr(title, C_Prediction) > 0)
        If InStr(title, C_Gym) > 0 Then
            Set sh = shGymEffective
        Else
            Set sh = shMatchEffective
        End If
        Call MakeADataSet(sh, idx, isPredict)
    Next
    Call doMacro
End Sub

'   期待個体テーブルのクリア
Public Sub ClearNewEntries()
    Dim i As Long
    For i = 1 To ListObjects.count
        With ListObjects(i)
            If Not .DataBodyRange Is Nothing Then
                .DataBodyRange.Clear
                .Resize Range(.HeaderRowRange, .DataBodyRange.rows(1))
            End If
        End With
    Next
End Sub

'   一列作成
Private Sub MakeADataSet(ByVal sh As Worksheet, ByVal idx As Integer, _
                    Optional ByVal isPredict As Boolean = True)
    Dim rnkCols, neCols, indCols, rCol As Variant
    Dim rRow, i As Long
    Dim headCel As Range
    Dim wcel As Range
    Dim settings As Object
    Dim lowLim, rnk As Integer
    
    Call getColumnTitles(indCols, rnkCols, neCols, isPredict)
    rnkCols = getColumnIndexes(sh, rnkCols)
    neCols = getColumnIndexes(ListObjects(idx), neCols)
    With ListObjects(idx)
        '   クリア
        If Not .DataBodyRange Is Nothing Then
            .DataBodyRange.Clear
            .Resize Range(.HeaderRowRange, .DataBodyRange.rows(1))
        End If
        '   ヘッダ先頭セル
        Set headCel = .HeaderRowRange.cells(1)
        '   カウント順位下限
        Set settings = getSettings(NER_CountLower)
        lowLim = settings(headCel.Offset(-1, 0).Text)
    End With
    Set wcel = headCel.Offset(1, 0)
    With sh.ListObjects(1).DataBodyRange
        '   ジムまたは対戦ランクのループ
        For rRow = 1 To .rows.count
            For Each rCol In rnkCols    '   基本ランクと天候差分の名前の列
                With .cells(rRow, rCol)
                    rnk = .Offset(0, -1).Value  '   ランク。名前の直前に決め打ち
                    '   名前があり、かつ（下限がないか、ランクが下限以内）
                    If .Text <> "" And (lowLim = 0 Or rnk <= lowLim) Then
                        '   予測で文字色が赤、或いは現在
                        If (isPredict And .Font.ColorIndex = BE_NewEntryColorIndex) _
                                Or (Not isPredict) Then
                            Call WriteCount(.Text, headCel, wcel, neCols, indCols)
                        End If
                    End If
                End With
            Next
        Next
    End With
    Call sortTable(ListObjects(idx), NE_EntryNum, xlDescending)
End Sub

'   関係表の列タイトルの取得
Private Sub getColumnTitles(ByRef indCols, ByRef rnkCols, ByRef neCols, _
                    ByVal isPredict As Boolean)
    rnkCols = Array(BE_CtrName & BE_SuffixPredictBase, _
                    BE_CtrName & BE_SuffixPredictWeather)
    neCols = Array(NE_Name, NE_EntryNum, NE_PL, NE_prPL, NE_Candies, NE_Sands, NE_Type)
    indCols = Array(IND_PL, IND_prPL, IND_Candies, IND_Sands)
    Exit Sub
    If isPredict Then
        rnkCols = Array(BE_CtrName & BE_SuffixPredictBase, _
                        BE_CtrName & BE_SuffixPredictWeather)
        neCols = Array(NE_Name, NE_EntryNum, NE_PL, NE_prPL, NE_Candies, NE_Sands, NE_Type)
        indCols = Array(IND_PL, IND_prPL, IND_Candies, IND_Sands)
    Else
        rnkCols = Array(BE_CtrName & BE_SuffixBase, _
                        BE_CtrName & BE_SuffixWeather)
        neCols = Array(NE_Name, NE_EntryNum, NE_PL, NE_Candies, NE_Sands, NE_Type)
        indCols = Array(IND_PL, IND_Candies, IND_Sands)
    End If
End Sub

'   カウントを書き込む
Private Sub WriteCount(ByVal name As String, ByRef headCel As Range, ByRef wcel As Range, _
                    ByRef neCols As Variant, ByRef indCols As Variant)
    Dim rcel As Range
    Dim attr, vals, types As Variant
    Set rcel = Range(headCel, wcel).Find(name, LookAt:=xlWhole)
    '   期待個体表に名前がないので行を作成
    If rcel Is Nothing Then
        '   個体表より属性取得
        attr = seachAndGetValues(name, IND_Nickname, shIndividual, indCols)
        types = seachAndGetValues(name, IND_Nickname, shIndividual, Array(IND_Type1, IND_Type2))
        '   書き込み
        vals = Array(name, 1, attr(0), attr(1), attr(2), attr(3))
        For i = 0 To UBound(vals)
            wcel.Offset(0, neCols(i) - 1).Value = vals(i)
        Next
'        types = getSpcAttrs(attr(4), Array(SPEC_Type1, SPEC_Type2))
        '   タイプの書き込み。最後のインデックスに決め打ち
        Call setTypeToCell(types, wcel.Offset(0, neCols(i) - 1), True)
        Set wcel = wcel.Offset(1, 0)
    Else    '   既存の行にカウント追加
        With rcel.Offset(0, neCols(1) - 1)
            .Value = .Value + 1
        End With
    End If
End Sub

